import { readFile, writeFile } from "fs/promises"
import assert from "node:assert";

/**
 * No try catches.
 * We actually want this to break if anything fails.
 */

//#region Constants
const ERROR_CODE_PREFIX = "ERROR_";
const ERROR_MESSAGE_PREFIX = "ERROR_MSG_"
//#endregion

//#region Paths
const configsPath = "./configs.json";
const errorCodesPath = "./include/constants/error_codes.h";
const errorMessagesPath = "./include/constants/error_messages.h";
const serverConfigsPath = "./include/constants/configs.h";
const errorUtilsPath = "./src/utils/error_message.c";
//#endregion

//#region Template utils
const addQuotes = (content) => typeof content === "string" ? `"${content}"` : content;

const dataRowToConfig = ({ name, content }) => `#define ${name.toLocaleUpperCase()} ${addQuotes(content)}`;

const headerTemplate = (name, data) => `/*
*
* WARNING: Any changes here could get overriden.
* This file was autogenerated.
*
* To update, please use 'config.json' and run '$ make configs'
*
*/

#ifndef ${name}
#define ${name}

${data}

#endif
`

const implementationTemplate = (content) => `//-automated-code-begins
    \n${content}\n
//-automated-code-ends`
//#endregion

//#region Errors
const getErrorMessages = (configs) =>
    configs.errors.map(({ name, message }) => ({
        name: `${ERROR_MESSAGE_PREFIX}${name}`,
        content: message,
    }));


const getErrorCodes = (configs) =>
    configs.errors.map(({ name, code }, index) => ({
        name: `${ERROR_CODE_PREFIX}${name}`,
        content: code ?? -index,
    }));
//#endregion

//#region Generate files
const generateErrorCodes = async (data) => {
    assert(typeof data === "string");

    await writeFile(errorCodesPath, headerTemplate("ERROR_CODES", data));
}

const generateErrorMessages = async (data) => {
    assert(typeof data === "string");

    await writeFile(errorMessagesPath, headerTemplate("ERROR_MESSAGES", data));
}

const updateErrorUtils = async (configs) => {
    const utilsC = await readFile(errorUtilsPath, "utf8");

    const newSwitches = configs.errors.map(({ name }) => `    case ${ERROR_CODE_PREFIX}${name}:\n        message = ${ERROR_MESSAGE_PREFIX}${name};\n        break;`).join("\n\n")

    await writeFile(errorUtilsPath, utilsC.replace(/\/\/-automated-code-begins[\s\S]*?\/\/-automated-code-ends/g, implementationTemplate(newSwitches)));
}

const generateServerConfigs = async (data) => {
    assert(typeof data === "string");

    await writeFile(serverConfigsPath, headerTemplate("CONFIGS", data));
}
//#endregion

const parseConfigs = async () => {
    const rawConfigs = await readFile(configsPath, "utf8");
    return JSON.parse(rawConfigs);
}

const toC = (configs) => {
    assert(!!configs?.errors?.length);
    assert(!!configs?.server);

    return {
        errorCodes: getErrorCodes(configs)
            .map(dataRowToConfig)
            .join("\n"),

        errorMessages: getErrorMessages(configs)
            .map(dataRowToConfig)
            .join("\n"),

        serverConfigs: Object.entries(configs.server)
            .map(([name, content]) => dataRowToConfig({ name, content }))
            .join("\n"),
    }
}

void (async () => {
    const configs = await parseConfigs();

    const {
        errorCodes,
        errorMessages,
        serverConfigs,
    } = toC(configs);

    await generateErrorCodes(errorCodes);
    await generateErrorMessages(errorMessages);
    await generateServerConfigs(serverConfigs);

    await updateErrorUtils(configs);
})();
